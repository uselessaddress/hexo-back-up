title: LFS学习笔记
date: 2013-11-19 11:38:47
tags: 
- Linux
- LFS
categories: 精华转载
---

1、chmod -v a+wt $LFS/sources
chmod a+wt是将目录或文件的属性设置为1777，这样任何人都可以对其进行读写。
当一个目录被设置为"粘着位"(用chmod a+t),则该目录下的文件只能由
一、超级管理员删除
二、该目录的所有者删除
三、该文件的所有者删除
也就是说,即便该目录是任何人都可以写,但也只有文件的属主才可以删除文件
可以参考http://blog.sina.com.cn/s/blog_49302a850100gfrs.html 

2、exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ '/bin/bash
exec的作用是执行一个可执行文件来替换掉当前进程（注意进程号并没有改变），env -i 就是以后面的环境变量来执行 /bin/bash。经过上面的整条命令，linux将用一个全新的shell来执行接下来的命令，这样可以去除掉很多环境变量。 

3、set +h
该命令是关闭bash的 hash功能。Hash通常是一个有用的特性 —bash使用一个hash表来记录可执行文件的完整路径，以避免为寻找同一个可执行文件而反复搜索PATH里的目录。
<!--more-->
4、make -C ld clean 
表示先进入ld目录，然后执行ld/Makefile中的clean目标

5、make -C ld LIB_PATH=/tools/lib   
进入ld目录进行make，同时将make的环境变量LIB_PATH设置为/tools/lib,该环境变量指定了链接器的默认搜索路径。

6、make bootstrap    
该命令一般在编译编译器时用。这个bootstrap不只是编译GCC，而要连着编译多次，它第一次用主机的GCC进行编译，第二次用刚编译好的GCC编译，然后再用编译好的GCC编译，然后会毕较第二次和第二次的结果以确保它能正确无误的生成它自己。

7、sed 's@^/lib/ld-linux.so.2@/tools&@g'
把/lib/ld-linux.so.2全部换成/tools/lib/ld-linux.so.2，@在这里只是一个分隔符，与常用的/一样。不论什么字符，紧跟着s命令的都被认为是新的分隔符！！

8、dirname $(gcc -print-libgcc-file-name)
该命令是获取libgcc.a文件的路径名，如/usr/lib/gcc/i486-linux-gnu/4.3.3

9、find ${GCC_INCLUDEDIR}/* -maxdepth 0 -xtype d -exec rm -rvf '{}'  \;   
该命令表示删除GCC_INCLUDEDIR目录下的所有目录文件， -maxdepth 0表示只查找GCC_INCLUDEDIR，而不查找其子目录。

10、grep -l "DO NOT EDIT THIS FILE"${GCC_INCLUDEDIR}/*  
输出在$GCC_INCLUDEDIR目录下的文件中包含"DO NOT EDIT THIS FILE"字符串的文件名。

11、ln  -sv  $LFS/tools  /    
/tools -> $LFS/tools
ln -s源文件 目标文件  -s是 symbolic的意思 该命令是用于建立软链接。当没有指定目标文件名时，则目标文件名与源文件名相同，当没有指定源文件的路径时，则源文件的路径与目标文件的路径相同。

12、useradd -s /bin/bash -g lfs -m -k /dev/null lfs
上面的命令为增加一个用户名为lfs的用户。-s 指定用户的默认shell为/bin/bash, -g lfs将用户添加到lfs组，-m为用户创建home目录，-k /dev/null
这个参数通过将输入位置修改为特殊的空设备来防止从框架目录(默认是 /etc/skel) 拷贝文件。最后的lfs为用户的用户名。之后可以通过passwd lfs来修改密码。

13、patch -Np1 -i /lfs-sources/expect-5.43.0-spawn-1.patch
-N表示忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使用过。-p表示要去掉斜线的个数，在这里-p1表示去掉一个"/"即补丁文件是lfs-sources/expect-5.43.0-spawn-1.patch, 如果用-p2则表示使用的补丁文件是expect-5.43.0-spawn-1.patch. patch一般都是在需要打补丁的文件所在的目录下执行。如果打完补丁后又不想打了，那可以使用-R选项来进行恢复，即patch -Rp1 -i /lfs-sources/expect-5.43.0-spawn-1.patch 

14、cp configure{,.bak}  
 复制configure且新的文件名为configure.bak
 
15、sed 's@\./fixinc\.sh@-c true@' gcc/Makefile.in.orig >gcc/Makefile.in  
该命令为将gcc/Makefile.in中的./fixinc.sh换为-c ture   Makefile.in.orig为Makefile.in的一个副本，@在这里为分隔符

16、sed 's/^XCFLAGS =$/& -fomit-frame-pointer/' gcc/Makefile.in.orig >gcc/Makefile.in  
将gcc/Makefile.in中的XCFLAGS=$换为XCFLAGS=$ -fomit-frame-pointer   "/"在这里为分隔符，&表示前面的匹配项“XCFLAGS =$”, ^符号表示行首。注意-fomit前面有一个空格，该空格是不可以省略的！

17、sed -i 's@/usr/include@/tools/include@g' configure 
将configure中的/usr/include全部替换成/tooles/include, g表示全部替换，如果没有g，那只表示只替换第一行中的第一个匹配项。

18、make -C mount mount umount
先进入mount目录，然后执行该目录下Makefile中的mount目标，再执行umount目标。

19、chown -R root:root $LFS/tools  
表示将$/LFS/tools下的所有文件（包括子目标的文件）的拥有者改成root,用户组也改成root，命令中的第一个root表示用户，第二个root表示用户组

20、mkdir -pv $LFS/{dev,proc,sys} 
在$LFS/目录下创建dev,proc,sys这三个目录文件

21、install -dv -m 1777 /tmp /var/tmp 
以1777的模式创建/tmp /var /var/tmp这三个目录文件，如果目录文件已存在，则会复盖原来的文件，另外需要注意的是/var这个目录文件的模式并不是1777，而是系统默认的 模式。该命令也等同于mkdir -pv -m 1777 /tmp  /var/tmp 只是mkdir创建时，如果目录文件已存在，则会创建会失败。

22、mkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}
创建 /usr/{bin,include,lib,sbin,src} /usr/local/{bin,include,lib,sbin,src}等目录文件 

23、sed-i '/vi_VN.TCVN/d' localedata/SUPPORTED  
将/localedata/SUPPORTED文件中vi_VN.TCVN所在的行删除

24、sed -i 's|@BASH@|/bin/bash|' elf/ldd.bash.in  
将elf/ldd.bash.in文件中的@BASH@替换为/bin/bash，符号｜在这里为分隔符。

25、
```
gcc -dumpspecs | sed \
-e 's@/tools/lib/ld-linux.so.2@/lib/ld-linux.so.2@g' \
-e '/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' \
-e '/\*cpp:/{n;s@$@ -isystem /usr/include@}' > \
`dirname $(gcc --print-libgcc-file-name)`/specs
```
gcc -dumpspecs是输出specs文件  sed命令中 -e表示在同一行执行那三个操作 最后的\表示转义回车键
's@/tools/lib/ld-linux.so.2@/lib/ld-linux.so.2@g'：将/tools/lib/ld-linux.so.2全部换为/lib/ld-linux.so.2
'/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/@}'如果匹配*startfile_prefix_spec:则将下一行换为/usr/lib/ 其中的.*表示匹配所有字符
/\*cpp:/{n;s@$@ -isystem /usr/include@}：如查匹配*cpp:，则将下一行的$换为：-isystem/usr/include
这里的命令如果对specs这个文件有所了解，那么会更容易理解，该文件格式差不多如下：
%cmmand  ,即%后接的是命令
*[specs_name]: 该语句单独成一行，以*号开头，紧接着的一行为specs字符串的值。具体情况可以参考GCC手册

26、sed -i 's/install_to_$(INSTALL_DEST) //' libiberty/Makefile.in 
将Makefile.in文件中的install_to_$(INSTALL_DEST)替换为空，即将该字符串删除。

27、export PS1="\$? [\u@\h \w]\$ "
export PS1="\[\e[31m\]\$? \[\e[32m\][\u@\h \w]\$ \[\e[m\]"

28、readelf -l <二进制文件> ｜ grep interpreter
该命令可以用于查看 二进制文件用的是哪个动态链接器

连接器的一个重要文面是它的库搜索顺序，将--verbose传递给ld可能是获理详细的信息，例如，输入命令：ld --verbose | grep SEARCH 将显示当前搜索路径和顺序

要显示ld连接的是如些文件，可以编译一个伪程序，并把--verbose选项传递给连接器。举个例子，输入 gcc dummy.c -Wl,--verbose 2>&1 | grep succeeded

要想知道gcc会使用哪个标准的连接器，可以使用gcc -print-prog-name=ld 命令

gcc - dummy.c 将显示在预处理、编译和汇编各个阶段的详细信息，包括gcc文件包含的搜索路径及其顺序。 