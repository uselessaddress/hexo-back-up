---
title: SVM迷你项目
toc: true
date: 2017-02-18 20:00:00
tags:
- 转载
- 机器学习
categories: 精华转载
---
# 项目背景
在此迷你项目中，我们将解决与朴素贝叶斯迷你项目相同的电子邮件作者 ID 问题，不同的是我们将运用 SVM。我们的研究结果将阐明两种算法之间的一些实际差异。此项目还向我们提供比朴素贝叶斯更多的机会来使用参数，因此我们也将这样做。

<!--more-->

# 运行代码
转到 svm 目录，查找初始代码 (svm/svm_author_id.py)。

使用 sklearn SVC 分类器进行导入、创建、训练和预测。在创建分类器时使用线性内核（如果你忘记此步骤，你会发现分类器要花很长的时间来训练）。

分类器的准确率是多少？

# 时间
跟你在朴素贝叶斯迷你项目中所做的一样，将计时代码用于拟合和预测函数。与朴素贝叶斯相比，训练和预测如何计时？

朴素贝叶斯结果：
```
training time: 1.517 s
0.973265073948
```

SVM结果：
```
training time: 207.594 s
0.984072810011
```

# 减小训练集
加快算法速度的一种方式是在一个较小的训练数据集上训练它。这样做换来的是准确率几乎肯定会下降。让我们更具体地探讨这个问题：在训练分类器之前，立即加入以下两行。 
```
features_train = features_train[:len(features_train)/100] 
labels_train = labels_train[:len(labels_train)/100] 
```

这两行有效地将训练数据集切割至原始大小的 1%，丢弃掉 99% 的训练数据。你可以使其他所有代码保持不变。

现在的准确率是多少？
修改后SVM结果：
```
training time: 0.124 s
0.884527872582
```

# 速度与准确率
如果速度是一个主要考虑因素（对于许多实时机器学习应用而言确实如此），并且如果牺牲一些准确率可加快你的训练/预测速度，则你可能会想这样做。

在以下哪些应用中，你可以想象非常快速地运行的算法尤其重要？

1、预测电子邮件作者
2、标记信用卡欺诈，在欺诈发生之前阻止交易
3、Siri 之类的语音识别

答案是2和3。

# 部署RBF内核
保留上一个测试题中的训练集代码段，以便仍在 1% 的完整训练集上进行训练。将 SVM 的内核更改为“rbf”。

这个更复杂的内核给出的准确率是多少？
```
training time: 0.139 s
0.616040955631
```

# 优化C参数
保持训练集大小不变，并且保留上一个测试题中的 rbf 内核，但是尝试多个 C 值（比如：10.0、100.、1000. 和 10000.）。

哪个给出的准确率最高？结果依次为：
```
training time: 0.142 s
0.616040955631

training time: 0.139 s
0.616040955631

training time: 0.132 s
0.821387940842

training time: 0.127 s
0.892491467577
```

**优化C后的准确率**
在你为 RBF 内核优化了 C 值后，你会获得怎样的准确率？该 C 值是否对应更简单或者更复杂的决策边界？

（如果你不确定复杂度，请回顾本节课有关“SVM C 参数”的视频。你在该处发现的结果同样适用于此处，不过，在简单的散点图中画出决策边界现在变得更加困难甚至不可能。）

# 优化C后使用完整训练集
你已经为 RBF 内核优化了 C，现在恢复为使用完整的训练集。较大的训练集往往能提高算法的性能，所以（通过在大数据集上调整 C 和进行训练）我们应得到相当优化的结果。

经过优化的 SVM 的准确率是多少？
```
training time: 142.459 s
0.990898748578
```

# 从SVM提取预测
你的 SVM（0 或 1，分别对应 Sara 和 Chris）将测试集中的元素10、元素26和元素50分别预测为哪一类？

（使用 RBF 内核、C=10000 和 1% 的训练集。通常，使用完整的训练集能获得最好的结果，但是我们发现使用 1% 的完整训练集不仅大幅加快计算过程，而且不会改变我们的结果，因此你在这里可以随意使用该快捷算法。）

而且需要说明的是，我们这里给出的数据点数字 (10, 26, 50) 假设使用的是零索引列表。因此，使用类似于 answer=predictions[100] 的表达式可找到元素 # 100 的正确答案。

# 预测Chris的邮件数量
There are over 1700 test events--how many are predicted to be in the “Chris” (1) class? (Use the RBF kernel, C=10000., and the full training set.) 

测试事件的数量超过 1700——其中多少预测在“Chris” (1) 类中？（使用 RBF 内核、C=10000. 以及完整的训练集。）

```
training time: 137.599 s
877
```

# 部署SVM最后提醒
希望 Sebastian 在说朴素贝叶斯非常适合文本时，更清楚地表达了他的意思。对于这一具体问题，朴素贝叶斯不仅更快，而且通常比 SVM 更出色。当然，SVM 更适合许多其他问题。你在第一次求解问题时就知道该尝试哪个算法，这是机器学习艺术和科学性的一个体现。除了选择算法外，视你尝试的算法而定，你还需要考虑相应的参数调整以及过拟合的可能性（特别是在你没有大量训练数据的情况下）。

我们通常建议你尝试一些不同的算法来求解每个问题。调整参数的工作量很大，但你现在只需要听完这堂课，我们将向你介绍 GridCV，一种几乎能自动查找最优参数调整的优秀 sklearn 工具。

# 源码分享
https://github.com/voidking/ud120-projects

# 书签
机器学习入门
https://cn.udacity.com/course/intro-to-machine-learning--ud120

